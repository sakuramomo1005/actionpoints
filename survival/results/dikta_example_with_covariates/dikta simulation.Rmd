---
title: "Mimic Dikta's simulation"
date: 2020-03-30
output: pdf_document
header-includes:
  - \usepackage{color}
fontsize: 12pt
---


```{R include = FALSE}

library(knitr)
library(kableExtra)

```


Dikta proposed another semi-parametric estimator with consideration of covariates. 
The estimator is derivatived from the estimator generated by Stute (1993), instead of the product limit estimator from Kaplan Meier. 

The Stute estimator (which estimates $E(\phi(x,t))$): 
\begin{equation}F_0(x,t) = P(X \leq x, Z \leq t) = \sum_{i=1}^n W_i \phi(x,t)\end{equation}
If we set $\phi(x,t) = I_{(X_i \leq x, Z_i \leq t)}$, it leads to
\begin{equation}F_0(x,t) = \sum_{i=1}^n W_i I_{(X \leq x, Z \leq t)} = \sum_{i=1}^n \big \{ \frac{\delta_i}{n - i + 1} \big[ \prod_{j = 1}^{i-1} (1 - \frac{1}{n-j + 1})^{\delta_i} \big ] \big \} I_{(X_i \leq x, Z_i \leq t)}\end{equation}
where $W_i = \frac{\delta_i}{n - i + 1} \prod_{j = 1}^{i-1} (1 - \frac{1}{n-j + 1})^{\delta_i}$. 

<!-- \color{blue} Question: when $i = 1$, what is the production value?  -->
<!-- \color{black} -->

Dikta replaced $\delta_i$ with $m(t,x)$ and got
\begin{equation}S^{D3} =\sum_{i=1}^n  \big \{ \frac{m(Z_i, X_i)}{n - i + 1}  \big[ \prod_{j = 1}^{i-1} (1 - \frac{m(Z_i, X_i)}{n-j + 1})  \big] \big \} I_{(X_i \leq x, Z_i \leq t)}\end{equation}
Therefore, the esimators of Cox PH model and of Dikta's model are actually  estimating different things, i.e.

\color{blue}
Cox
$$S^{cox}(t | X = x) = P(T > t | X = x)$$
Dikta 
$$S^{D3} = P(T < t, X < x) = P(T < t, X_1 < x_1, ... , X_p < x_p)$$

\color{red}

<!-- Should $S^{cox}(t | X = x)$ and $S^{D3} = P(T < t, X < x)$ close to each other?  -->

Therefore, to calculate $ P(T < t, X < x)$ from $P(T < t | X = x)$, we then need some transformations.

\color{black}

Since,
$$\begin{aligned}
 \int_{0}^t f_{T,X}(t,x) dt = & \int_{0}^t f_{T|X}(t|x) f_X(x) dt \\
 = & f_X(x)  \int_{0}^t f_{T|X}(t|x) dt \\
 = & f_X(x) P(T < T | X = x)
\end{aligned}$$
then 
<!-- $$P(T < t | X = x) = \frac{1}{f_X(x)} \int_{0}^t f_{T,X}(t,x) dt =\frac{1}{f_X(x)} \frac{\partial }{\partial t} P(T < t, X < x)$$ -->

* $P(T < t | X = x) = \frac{1}{f_X(x)} \int_{0}^t f_{T,X}(t,x) dt$ 

* $f_{T,X}(t,x) = f_X(x)  \frac{\partial }{\partial t} P(T < t | X = x)$

* $\begin{aligned}F_{T,X}(t,x) =&  \int_0^x \int_0^t f_{T,X}(t,x) dt dx \\
=&   \int_0^x \int_0^t f_X(x)  \frac{\partial }{\partial t} P(T < t | X = x) dt dx \\
=& \int_0^x  f_X(x) P(T < t | X = x) dx
\end{aligned}$

Then for example, if we have one dimension covariate $X \sim N(0,1)$. The conditional distribution 
$$P(T > t | X = x) = S(t|x) = S_0(t)^{\exp(x)} = \exp(-t \times \exp(x))$$
$$P(T < t | X = x) = 1 - P(T > t | X = x) = 1 -  \exp(-t \times \exp(x))$$
$$\begin{aligned}
F_{T,X}(t,x)=& \int_0^x  f_X(x) P(T < t | X = x) dx \\
= & \int_0^x \frac{1}{\sqrt{2\pi}}\exp(-\frac{x^2}{2}) (1 -  \exp(-t \times \exp(x))) dx \\
= & \Phi(x) -0.5- \int_0^x \frac{1}{\sqrt{2\pi}}\exp(-\frac{x^2}{2}-t \exp(x)) dx
\end{aligned}$$
which does not have a close form. 


### Simulation settings in Dikta's paper

In Dikta's paper, he assume that $\psi(u,v) = I(u <x, v < y)$ for a given $(x,y)$ point. Therefroe, the Kaplan-Meier-biased estimator estimates $P(T < t, X < x)$. 

Consider a one dimensional covariate, $X$, with distribution $X \sim N(0.5, 1.5^2)$. 
Consider the lifetime given the covariate has the model: 
$$P(T < t | X = x) = 1 - \exp(-t \exp(-\rho x))$$
where $\rho = 1$ or $\rho = 3$. 
The censoring time follows the model 
$$P(C > t) = \exp(-t)$$
Therefore, the $F_{T,X}(t,x)$ function can be written as:
$$\begin{aligned}
F_{T,X}(t,x)=& \int_0^x  f_X(x) P(T < t | X = x) dx \\
= & \int_0^x \frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(x-\mu)^2}{2 \sigma^2}) \big(  1 - \exp(-t \exp(-\rho x)) \big) dx
\end{aligned}$$
And the $m()$ function is 
$$m(x,t) = 1/(1 + \exp(-\rho x))$$

The author just looked at three special points, $(x,t) = (1.5, 0.1), (x,t) = (1.5, 0.4), (x,t) =(1.5, 1.3)$. 
We may calculate the $F_{T,X}(t,x)$ with those settings. 

```{r}

fxy = function(x,t){
  res = 0; h = 0.00001
  for(i in seq(0,x,h)){
    temp = 1/ (sqrt(2*pi)*sigma) * 
      exp(-(i-mu)^2/(2*sigma^2)) *
      (1-exp(- t*exp(rho*i))) 
    res = res + temp * h
  }
  res
  return(res)
}

```


```{R include = FALSE}
mu = 0.5; sigma = 1.5; rho = 1
x = 1.5; t = 0.1
print(paste('when rho = ', rho, ', x = ',x,', t = ',t, ', fxy =', round(fxy(x,t),4)))
x = 1.5; t = 0.4
print(paste('when rho = ', rho, ', x = ',x,', t = ',t, ', fxy =', round(fxy(x,t),4)))
x = 1.5; t = 1.3
print(paste('when rho = ', rho, ', x = ',x,', t = ',t, ', fxy =', round(fxy(x,t),4)))

mu = 0.5; sigma = 1.5; rho = 3
x = 1.5; t = 0.1
print(paste('when rho = ', rho, ', x = ',x,', t = ',t, ', fxy =', round(fxy(x,t),4)))
x = 1.5; t = 0.4
print(paste('when rho = ', rho, ', x = ',x,', t = ',t, ', fxy =', round(fxy(x,t),4)))
x = 1.5; t = 1.3
print(paste('when rho = ', rho, ', x = ',x,', t = ',t, ', fxy =', round(fxy(x,t),4)))

```

```{R echo = FALSE}
res = c()
mu = 0.5; sigma = 1.5; rho = 1
x = 1.5; t = 0.1
res = c(res,round(fxy(x,t),4))
x = 1.5; t = 0.4
res = c(res,round(fxy(x,t),4))
x = 1.5; t = 1.3
res = c(res,round(fxy(x,t),4))
mu = 0.5; sigma = 1.5; rho = 3
x = 1.5; t = 0.1
res = c(res,round(fxy(x,t),4))
x = 1.5; t = 0.4
res = c(res,round(fxy(x,t),4))
x = 1.5; t = 1.3
res = c(res,round(fxy(x,t),4))

res = rbind(c(0.0917, 0.2746, 0.4967, 0.2272,0.3446,0.4385),res)
colnames(res) = c('t = 0.1','t = 0.4','t = 1.3',
             't = 0.1','t = 0.4','t = 1.3')
rownames(res) = c('In Dikta paper','Mine calculation')


kable(res, "latex", align="c", booktabs=TRUE, escape = F, longtable = T) %>%
  add_header_above(header = c(" " = 1,"x = 1.5; rho = 1" = 3, "x = 1.5; rho = 3" = 3)) 


```

However, the results are not quite similar. 

For the calculation of Kaplan-Meier-based estimator: 

```{R echo= FALSE}

load("~/Desktop/NYU/Research/Survival/11/diktamimic.RData")

```

For the calculation of Dikta's semiparameter estimator: 

```{R include = FALSE}
# apply(result$dks, 2, mean)
# apply(result$kms, 2, mean)
```

The Stute estimator (which estimates $E(\phi(x,t))$): 
\begin{equation}F_0(x,t) = \sum_{i=1}^n \big \{ \frac{\delta_i}{n - i + 1} \big[ \prod_{j = 1}^{i-1} (1 - \frac{1}{n-j + 1})^{\delta_i} \big ] \big \} I_{(X_i \leq x, Z_i \leq t)}\end{equation}

```{R}
km_x = function(t, x, data){
  n = dim(data)[1]
  temp = 0
  for(i in 1:n){
    if(data$time[i] < t & data$x[i] <= x){
      # print(i)
      w = 1
      if(i == 1){
        w = w * data$status[i]/(n - i + 1)
        temp = temp + w
      }else{
        for(j in 1:(i - 1)){
          w = w * (1 - data$status[j]/(n - j + 1))
        }
        w = w * data$status[i]/(n - i + 1)
        temp = temp + w
      }
    }
  }
  return(temp)
}

```


Dikta replaced $\delta_i$ with $m(t,x)$ and got
\begin{equation}S^{D} =\sum_{i=1}^n  \big \{ \frac{m(Z_i, X_i)}{n - i + 1}  \big[ \prod_{j = 1}^{i-1} (1 - \frac{m(Z_i, X_i)}{n-j + 1})  \big] \big \} I_{(X_i \leq x, Z_i \leq t)}\end{equation}

```{R}
dikta_x = function(t, x, data){
  n = dim(data)[1]
  temp = 0
  for(i in 1:n){
    if(data$time[i] < t & data$x[i] <= x){
      # print(i)
      w = 1
      if(i == 1){
        w = w * mm(data$x[i], data$time[i])/(n - i + 1)
        temp = temp + w
      }else{
        for(j in 1:(i - 1)){
          w = w * (1 - mm(data$x[j], data$time[j])/(n - j + 1))
        }
        w = w * mm(data$x[i], data$time[i])/(n - i + 1)
        temp = temp + w
      }
    }
  }
  return(temp)
}
# m function
mm = function(x,y){
  v =  r*x + log(c) - log(a) + (c-a)*log(y)
  temp = 1/(1 + exp(v))
  return(temp)
}
```

#### Results

```{R echo = FALSE}
# apply(result$dks, 2, mean) - c( 0.0754, 0.2148, 0.3430)
# apply(result$kms, 2, mean) - c( 0.0754, 0.2148, 0.3430)
# # 
# # apply(result$dks, 2, mean) - c(0.0917, 0.2746, 0.4967)
# # apply(result$kms, 2, mean) - c(0.0917, 0.2746, 0.4967)
# apply(result$dks, 2, sd)
# apply(result$kms, 2, sd)
# 
# apply((result$dks-matrix(c(0.0754,0.2148,0.3430),1000,3,byrow = TRUE))^2,2,mean)
# apply((result$kms-matrix(c(0.0754,0.2148,0.3430),1000,3,byrow = TRUE))^2,2,mean)

res = cbind(cbind(apply(result$kms, 2, mean) - c( 0.0754, 0.2148, 0.3430), 
      apply(result$kms, 2, sd),
      apply((result$kms-matrix(c(0.0754,0.2148,0.3430),1000,3,byrow = TRUE))^2,2,mean)),
cbind(apply(result$dks, 2, mean) - c( 0.0754, 0.2148, 0.3430), 
      apply(result$dks, 2, sd),
      apply((result$dks-matrix(c(0.0754,0.2148,0.3430),1000,3,byrow = TRUE))^2,2,mean)))
res = round(res,4)

colnames(res) = c('Bias','SD','MSE', 'Bias','SD','MSE')
rownames(res) = c('t = 0.1', 't = 0.4', 't = 1.3')

kable(res, "latex", align="c", booktabs=TRUE, escape = F, longtable = T) %>%
  add_header_above(header = c(" " = 1,"Kaplan-Meier-biased" = 3, "Dikta semiparametric" = 3)) 

```




